
# Testing Go Code (Basics)

This document explains the basic rules of writing tests in Go using simple English.

---

## 1. Test File Name

A Go test file **must end with `_test.go`**.

### Examples
```go
math_test.go
user_service_test.go
````

Go only runs test files that follow this naming rule.

---

## 2. Test Function Name

A test function **must start with `Test` (uppercase T)**.

### Correct

```go
func TestAdd(t *testing.T) {}
```

### Wrong

```go
func testAdd(t *testing.T) {}    // lowercase t
func CheckAdd(t *testing.T) {}  // does not start with Test
```

Go uses the function name to detect test functions.

---

## 3. Test Function Parameter

Every test function must have **exactly one parameter**:

```go
t *testing.T
```

### Example

```go
func TestAdd(t *testing.T) {
    // test logic
}
```

### Why `*testing.T` and not `testing.T`?

* Go passes values by copy
* `testing.T` holds test state (fail status, logs, etc.)
* Using a pointer (`*testing.T`) avoids copying
* Changes affect the real test state
* The test runner can correctly detect failures

All test methods (`Fail`, `Error`, `Fatal`, etc.) are defined on `*testing.T`.

---

## 4. Common `testing.T` Methods

### Fail but continue the test

```go
t.Error("something went wrong")
t.Errorf("expected %d, got %d", 1, result)
```

### Fail and stop the test immediately

```go
t.Fatal("critical error")
t.Fatalf("cannot continue test")
```

### Log messages (visible with `go test -v`)

```go
t.Log("this is a log message")
```

---

## 5. Simple Test Example

```go
func TestSum(t *testing.T) {
    result := Sum(2, 3)
    if result != 5 {
        t.Errorf("expected 5, got %d", result)
    }
}
```

---

## 6. Subtests

Go supports subtests using `t.Run`.

```go
func TestMath(t *testing.T) {
    t.Run("addition", func(t *testing.T) {
        if 2+2 != 4 {
            t.Fail()
        }
    })

    t.Run("subtraction", func(t *testing.T) {
        if 5-3 != 2 {
            t.Fail()
        }
    })
}
```

---

## 7. Running Tests

Run all tests:

```bash
go test
```

Run tests with verbose output:

```bash
go test -v
```

---

## Summary

* Test files must end with `_test.go`
* Test functions must start with `Test`
* Test functions receive `t *testing.T`
* Use `t` to report test results
* Go automatically detects and runs tests


## Test example

```go

package main
import (
	"testing"
	"os"  
	"strings"
	"slices"
)

func TestWriteToFile(t *testing.T) {
	cards := Deck{"hi" , "by"}
	fileName := "fileName"
	cards.writeToFile(fileName)
	data , err := os.ReadFile(fileName)
	if err != nil {
		t.Error("Error in reading file" , err)
	}
	dataString := string(data)
	if dataString == "" {
		t.Error("file is empty")
	}
	savedCards := Deck(strings.Split(dataString , ","))

	if slices.Equal(savedCards , cards) == false {
		t.Error("Cards saved Incorrectly")
	}

}

```

# Comparable Types

In Go, **`comparable` is a type constraint** used with **generics**.

It means:

> *“This type supports `==` and `!=` comparisons.”*

---

## What does `comparable` include?

A type is `comparable` if Go allows you to do:

```go
a == b
a != b
```

### ✅ Comparable types

* All **basic types**

  * `int`, `float64`, `string`, `bool`
* **Pointers**
* **Channels**
* **Interfaces** (if their dynamic value is comparable)
* **Structs** (if *all fields* are comparable)
* **Arrays** (if element type is comparable)

### ❌ Not comparable

* **Slices**
* **Maps**
* **Functions**

Example (invalid):

```go
var a []int
var b []int
_ = a == b // ❌ compile-time error
```

---

## Why is `comparable` used?

It’s mainly used with **generic functions** so Go knows it’s safe to use `==`.

### Example: generic slice comparison

```go
func slicesEqual[T comparable](a, b []T) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] { // allowed because T is comparable
			return false
		}
	}
	return true
}
```

Here:

* `T comparable` tells Go:

  > “Any type used for `T` must support `==`.”

---

## What happens without `comparable`?

This won’t compile:

```go
func bad[T any](a, b []T) bool {
	return a[0] == b[0] // ❌ invalid operation
}
```

Because `any` might be a slice, map, etc.

---

## How this relates to slices

* **Slices themselves are NOT comparable**
* **Elements inside slices might be comparable**

That’s why this works:

```go
[]int        // elements are comparable
[]string     // comparable
[]MyStruct   // if fields are comparable
```

But this does not:

```go
[][]int      // element type is a slice → not comparable
[]map[string]int // not comparable
```

---
