In Go, **reflection** is the ability for a program to **inspect and manipulate values, types, and structure at runtime**, even when you donâ€™t know their concrete types at compile time.

Goâ€™s reflection lives in the **`reflect`** package.

---

## The core idea (in plain terms)

Normally in Go, types are fixed and known at compile time:

```go
var x int = 10
```

With reflection, Go lets you ask questions like:

* â€œWhat type is this value *right now*?â€
* â€œIs this a struct? A slice? A pointer?â€
* â€œWhat fields does this struct have?â€
* â€œCan I change this value dynamically?â€

---

## The three key concepts

### 1. `reflect.Type`

Describes **what something is** (its type).

```go
t := reflect.TypeOf(42)
fmt.Println(t)        // int
fmt.Println(t.Kind()) // int
```

---

### 2. `reflect.Value`

Represents **the actual value** and lets you work with it.

```go
v := reflect.ValueOf(42)
fmt.Println(v.Int()) // 42
```

---

### 3. `Kind`

A category of type (not the exact type).

Common kinds:

* `Int`, `String`, `Struct`
* `Slice`, `Map`
* `Ptr`, `Interface`, `Func`

```go
if v.Kind() == reflect.Int {
    fmt.Println("It's an int")
}
```

---

## Example: inspecting a struct

```go
type User struct {
    Name string
    Age  int
}

u := User{"Alice", 30}

t := reflect.TypeOf(u)
v := reflect.ValueOf(u)

for i := 0; i < t.NumField(); i++ {
    fieldType := t.Field(i)
    fieldValue := v.Field(i)

    fmt.Printf("%s (%s) = %v\n",
        fieldType.Name,
        fieldType.Type,
        fieldValue.Interface(),
    )
}
```

Output:

```
Name (string) = Alice
Age (int) = 30
```

---

## Modifying values with reflection (the tricky part)

You **can only modify values if they are addressable**, usually via pointers.

âŒ This wonâ€™t work:

```go
v := reflect.ValueOf(10)
v.SetInt(20) // panic
```

âœ… This works:

```go
x := 10
v := reflect.ValueOf(&x).Elem()
v.SetInt(20)

fmt.Println(x) // 20
```

---

## Common real-world uses

Reflection is powerful but **used sparingly** in Go:

* JSON / XML encoding (`encoding/json`)
* ORMs (GORM, sqlx)
* Validation libraries
* Dependency injection
* Generic-ish utilities (before Go had generics)

Youâ€™re probably already using reflection indirectly every time you call:

```go
json.Marshal(myStruct)
```

---

## When *not* to use reflection ğŸš«

* If generics can do the job
* If performance is critical
* If code clarity matters more than flexibility

Reflection:

* Is slower
* Breaks compile-time safety
* Is harder to read and maintain

Goâ€™s mantra applies here: **â€œClear is better than clever.â€**

---

## TL;DR

> **Reflection in Go** lets you examine and modify types and values at runtime using the `reflect` packageâ€”but it should be used carefully and only when necessary.


