# Interfaces

## 1. What is an interface in Go?

An **interface** in Go is a **set of method rules**.

It says:

> â€œIf a type has these methods, then it can be used here.â€

An interface **does not care** about:

* how the method works
* what the type is

It only cares about:

* **method names**
* **method parameters**
* **return types**

---

## 2. Simple real-world idea

Think about a **charger** ðŸ”Œ

You donâ€™t care:

* who made the charger
* how it works inside

You only care:

* it can **charge**

So the rule is:

```
Anything that can charge is a charger
```

That rule is an **interface**.

---

## 3. Basic interface syntax

### Define an interface

```go
type Speaker interface {
	Speak() string
}
```

This means:

* Any type that has a `Speak() string` method
* **automatically** becomes a `Speaker`

---

## 4. Implementing an interface (IMPORTANT)

In Go, you **do NOT write** `implements`.

If a type has the method â†’ it implements the interface.

### Example

```go
type Person struct {
	Name string
}

func (p Person) Speak() string {
	return "Hello, my name is " + p.Name
}
```

âœ… `Person` is a `Speaker`
(no keyword needed)

---

## 5. Using the interface

```go
func SaySomething(s Speaker) {
	fmt.Println(s.Speak())
}
```

Now we can pass **any type** that implements `Speak()`.

```go
p := Person{Name: "Alex"}
SaySomething(p)
```

---

## 6. Another implementation (same interface)

```go
type Dog struct{}

func (d Dog) Speak() string {
	return "Woof!"
}
```

Now:

```go
d := Dog{}
SaySomething(d)
```

ðŸŽ‰ Same function, different behavior.

---

## 7. Why interfaces are useful (real world)

### Problem without interface âŒ

```go
func PrintPerson(p Person) {}
func PrintDog(d Dog) {}
```

Too many functions.

---

### Solution with interface âœ…

```go
func PrintSpeaker(s Speaker) {}
```

âœ” clean
âœ” flexible
âœ” easy to extend

---

## 8. Interface with multiple methods

```go
type Vehicle interface {
	Start() error
	Stop() error
}
```

A type must implement **ALL methods**.

```go
type Car struct{}

func (c Car) Start() error {
	return nil
}

func (c Car) Stop() error {
	return nil
}
```

Now `Car` is a `Vehicle`.

---

## 9. Interface as a variable type

```go
var s Speaker
s = Person{Name: "Sam"}
fmt.Println(s.Speak())
```

The **real type** is hidden.
This is called **polymorphism**.

---

## 10. Empty interface (`interface{}`)

```go
var x interface{}
```

This means:

> x can be **ANY type**

Example:

```go
x = 10
x = "hello"
x = true
```

âš ï¸ Use carefully. It removes type safety.

---

## 11. Type assertion

Used to get the real value from an interface.

```go
value, ok := x.(string)
```

* `ok == true` â†’ success
* `ok == false` â†’ wrong type

Example:

```go
if str, ok := x.(string); ok {
	fmt.Println(str)
}
```

---

## 12. Type switch (very common)

```go
func PrintType(x interface{}) {
	switch v := x.(type) {
	case int:
		fmt.Println("int:", v)
	case string:
		fmt.Println("string:", v)
	default:
		fmt.Println("unknown")
	}
}
```

---

## 13. Interface embedding

Interfaces can include other interfaces.

```go
type Reader interface {
	Read() string
}

type Writer interface {
	Write(string)
}

type ReadWriter interface {
	Reader
	Writer
}
```

A type must implement **all embedded methods**.

---

## 14. Interfaces in real Go projects

Common real uses:

âœ” Database drivers (`database/sql`)

âœ” HTTP handlers (`http.Handler`)

âœ” Logging systems

âœ” Testing (mock objects)

âœ” Plug-in systems

---

## 15. Why Go interfaces are special

* No `implements` keyword
* Very small and simple
* Focus on **behavior**, not hierarchy
* Encourages clean design

---

## 16. Key rules to remember

âœ… Interfaces define **what**, not **how**

âœ… Types implement interfaces **automatically**

âœ… One type can implement **many interfaces**

âœ… Interfaces make code **flexible and testable**



# ReadWrite Interface 

1ï¸âƒ£ What is ReadWriter?

io.ReadWriter is just a combination of Reader and Writer.

```go

type ReadWriter interface {
    Reader
    Writer
}

```


Anything that can both read and write can implement ReadWriter.

Useful for streams where you send and receive data on the same object.

## 1. What are `Reader` and `Writer`?

In Go:

* **`io.Reader`** â†’ â€œI can give you dataâ€
* **`io.Writer`** â†’ â€œI can accept dataâ€

These are **interfaces**, which means **any type** that implements the required methods can be used wherever a Reader or Writer is needed.

---

### Reader

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

* `p []byte` â†’ the **buffer** you provide
* `n int` â†’ how many bytes were actually read
* `err error` â†’ tells if reading failed or finished (`io.EOF`)

> Only the first `n` bytes are valid. The rest of the buffer may contain leftover data.

---

### Writer

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

* `p []byte` â†’ data you want to write
* `n int` â†’ how many bytes were written
* `err error` â†’ tells if writing failed

> Write may write fewer bytes than you give. Always check `n`.

---

## 2. How `Read` works

* `Read` fills your buffer with new data **up to its length**.
* It **does not append** to any slice automatically.
* Returns `io.EOF` when no more data is available.

### Example: reading manually

```go
buf := make([]byte, 1024) // 1 KB buffer
for {
    n, err := reader.Read(buf)
    if n > 0 {
        process(buf[:n]) // only use the first n bytes
    }
    if err == io.EOF {
        break
    }
    if err != nil {
        panic(err)
    }
}
```

> Notice: Always use `buf[:n]` because the rest of the buffer may have leftover data from previous reads.

---

### Leftover Data

* **Leftover** = data in the buffer after the first `n` bytes
* Happens when:

  * Buffer is bigger than the data read
  * Buffer is reused and already contained old data
* **Never use leftover bytes**; always use `buf[:n]`.

**Example:**

```go
buf := make([]byte, 5)
buf[0], buf[1], buf[2], buf[3], buf[4] = 'x','y','z','w','v'

n := 3 // Read returns 3 bytes: 'a','b','c'
buf[0], buf[1], buf[2] = 'a','b','c'
// buf[3], buf[4] = 'w','v' â†’ leftover
```

---

## 3. Why `buf[:n]...` in `append`

```go
allData = append(allData, buf[:n]...)
```

* `buf[:n]` â†’ slice of only the valid data
* `...` â†’ spreads the slice elements so `append` can add them individually
* Prevents appending leftover bytes

**Wrong:**

```go
allData = append(allData, buf...) // may include invalid leftover bytes
```

---

## 4. How `Writer` works

```go
w.Write([]byte("hello"))
```

* Sends data to the destination (file, stdout, network, etc.)
* Returns how many bytes were actually written
* Might write fewer bytes than given â†’ always check return value

---

## 5. Combining Reader and Writer

Absolutely! Letâ€™s do a **complete and simple example** of `io.Copy` in Go. Iâ€™ll explain **what it does, why itâ€™s useful, and how it works**.

---

### 1ï¸âƒ£ What `io.Copy` does

```go
func Copy(dst Writer, src Reader) (written int64, err error)
```

* **dst** â†’ where to write (`io.Writer`)
* **src** â†’ where to read (`io.Reader`)
* **Returns**: total bytes copied and any error

**Key idea:** `io.Copy` reads from `src` in chunks and writes them to `dst` until EOF.

It **handles buffers and loops for you** â€” you donâ€™t need to manually read and append.

---

### 2ï¸âƒ£ Example 1: Copy a file

```go
package main

import (
    "io"
    "log"
    "os"
)

func main() {
    // Open source file
    srcFile, err := os.Open("source.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer srcFile.Close()

    // Create destination file
    dstFile, err := os.Create("destination.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer dstFile.Close()

    // Copy the content
    bytesCopied, err := io.Copy(dstFile, srcFile)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Copied %d bytes\n", bytesCopied)
}
```

**Explanation:**

1. `srcFile` â†’ implements `io.Reader`
2. `dstFile` â†’ implements `io.Writer`
3. `io.Copy(dstFile, srcFile)` â†’ reads chunks from the source and writes to destination automatically
4. No need to manually handle buffers

---

## 3ï¸âƒ£ Example 2: Copy HTTP response to file

```go
package main

import (
    "io"
    "log"
    "net/http"
    "os"
)

func main() {
    // Make HTTP GET request
    resp, err := http.Get("https://example.com")
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close() // Reader

    // Create a file to save response
    outFile, err := os.Create("example.html")
    if err != nil {
        log.Fatal(err)
    }
    defer outFile.Close() // Writer

    // Copy the response body to the file
    bytesCopied, err := io.Copy(outFile, resp.Body)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Downloaded %d bytes\n", bytesCopied)
}
```

**Notes:**

* `resp.Body` â†’ `io.Reader` (stream from network)
* `outFile` â†’ `io.Writer` (file on disk)
* `io.Copy` handles chunking and loops, efficient even for large files

---

### 4ï¸âƒ£ Key points about `io.Copy`

1. `io.Copy` uses **internal buffer** (default 32 KB)
2. Efficient: does not load the entire file into memory
3. Works with **any Reader â†’ Writer** pair: files, buffers, network connections
4. Returns **total bytes copied** and any error

---

## 5ï¸âƒ£ Mental model

```
[ src (Reader) ] â†’ [ io.Copy ] â†’ [ dst (Writer) ]
```

* Think of it as a conveyor belt: `io.Copy` grabs chunks from the source and puts them onto the destination until done.



### Example: API call using Reader

```go
resp, _ := http.Get("https://api.github.com")
defer resp.Body.Close() // Reader

buf := make([]byte, 1024)
for {
    n, err := resp.Body.Read(buf)
    if n > 0 {
        fmt.Print(string(buf[:n])) // use only valid bytes
    }
    if err == io.EOF {
        break
    }
}
```

* `resp.Body` is a **Reader**
* Data is read **in chunks**
* Buffer may be smaller than data â†’ multiple reads needed

---

### Streaming to a file

```go
file, _ := os.Create("output.txt")
defer file.Close()

buf := make([]byte, 4096)
for {
    n, err := resp.Body.Read(buf)
    if n > 0 {
        file.Write(buf[:n])
    }
    if err == io.EOF {
        break
    }
}
```

* Reads 4 KB at a time
* Appends each chunk to the file
* Efficient and memory-friendly

---

## 6. Choosing buffer size

* Buffer size does **not** need to match total data
* Only controls **how much you read at a time**
* Common practical sizes:

| Size    | When to use                        |
| ------- | ---------------------------------- |
| 1â€“4 KB  | normal network/file reads          |
| 8â€“32 KB | standard, efficient                |
| 64 KB+  | large streaming or high-throughput |

> Too small â†’ more reads, slightly slower
> Too large â†’ wastes memory

---

## 7. Important Notes / Best Practices

1. Always use `buf[:n]` when processing read data
2. `Read` **overwrites the buffer**, does **not append**
3. Leftover in buffer is **memory leftover**, not new data
4. For storing all data, append manually:

```go
allData = append(allData, buf[:n]...)
```

5. Use `defer` to **close resources** like files and response bodies

```go
defer resp.Body.Close()
defer file.Close()
```

6. For large or streaming data, **donâ€™t use `io.ReadAll`**, use chunked reads
7. `io.Copy` is **simpler** for common Reader â†’ Writer transfers

---

## 8. Mental Models

* **Reader** = faucet ðŸš° (gives data)
* **Writer** = sink ðŸª£ (receives data)
* **Buffer** = cup ðŸ¥¤ (temporary container)
* **Leftover** = whatâ€™s left in the cup from before

> Always scoop only the valid part of the buffer (`buf[:n]`), not the whole cup.

---

## 9. Summary

* `io.Reader` â†’ read data in chunks, returns `n` bytes, leftover may exist
* `io.Writer` â†’ write data in chunks, returns `n` bytes written
* `buf[:n]` â†’ only valid data
* `append(buf[:n]...)` â†’ combine multiple reads safely
* `io.Copy(dst, src)` â†’ handles reading & writing efficiently

---

This document covers everything we discussed, including **leftover bytes, buffer reuse, manual reading, append, defer, and API examples** â€” written in **easy English**.

---

If you want, I can also make a **small diagram showing buffer, n, leftover, and append**, which makes this **visually crystal clear** for beginners.

Do you want me to make that diagram too?



