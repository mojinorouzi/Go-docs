# Gin Framework

Gin is a high-performance HTTP web framework for Go that provides a simple and expressive API for building RESTful APIs and web applications.

Key features:

* Fast (up to 40x faster than some frameworks)
* Martini-like API with better performance
* Built-in middleware support
* JSON validation
* Route grouping
* Error management

---

## 1. Installation

```bash
go get -u github.com/gin-gonic/gin
```

---

## 2. Creating an HTTP Server

### Basic Server Setup

```go
package main

import "github.com/gin-gonic/gin"

func main() {
	r := gin.Default()
	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})
	
	r.Run() // Listen on 0.0.0.0:8080
}
```

### What is `gin.Default()`?

`gin.Default()` creates a Gin router with **Logger** and **Recovery** middleware already attached.

Equivalent to:

```go
r := gin.New()
r.Use(gin.Logger())
r.Use(gin.Recovery())
```

---

## 3. Middleware

### What is Recovery Middleware?

The **Recovery middleware** recovers from any panics during HTTP request handling:

* Prevents server crashes
* Returns a **500 Internal Server Error** response
* Logs the panic error and stack trace for debugging

```go
r.Use(gin.Recovery())
```

✅ `gin.Default()` includes both Logger and Recovery by default.

---

### Custom Middleware Example

```go
func customLogger() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Before request
		start := time.Now()
		
		c.Next() // Process request
		
		// After request
		duration := time.Since(start)
		fmt.Printf("Request took %v\n", duration)
	}
}

r.Use(customLogger())
```

---

## 4. Understanding `*gin.Context`

### What is `gin.Context`?

`*gin.Context` is a pointer to the context object that represents the current HTTP request.

It provides methods to:

| Category     | Methods                                      |
| ------------ | -------------------------------------------- |
| Read Request | Query, Param, BindJSON, BindUri, GetHeader   |
| Send Response| JSON, IndentedJSON, String, HTML, Redirect   |
| Control Flow | Next, Abort, AbortWithStatus                 |
| Data Storage | Set, Get (store data during request lifecycle)|

### Why Use a Pointer (`*gin.Context`)?

* Avoids copying large context objects
* Allows modifications to affect the original context
* More efficient memory usage

---

## 5. Route Handlers (Controllers)

Gin uses an **Express.js-like style** where you define routes and callback functions.

### GET Request Example

```go
r.GET("/ping", func(c *gin.Context) {
	c.JSON(200, gin.H{
		"message": "pong",
	})
})
```

**Explanation:**

* `r.GET` → Define GET route
* `"/ping"` → Route path
* `func(c *gin.Context)` → Handler function
* `c.JSON` → Send JSON response
* `gin.H` → Shortcut for `map[string]interface{}`

---

### POST Request Example

```go
type Item struct {
	ID   string `json:"id" binding:"required"`
	Name string `json:"name" binding:"required"`
}

var items []Item

func addItem(c *gin.Context) {
	var newItem Item
	
	// Bind and validate JSON body
	if err := c.BindJSON(&newItem); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	items = append(items, newItem)
	c.IndentedJSON(http.StatusCreated, newItem)
}

r.POST("/items", addItem)
```

**What does `c.BindJSON` do?**

* Parses JSON request body
* Validates against struct tags (`binding:"required"`)
* Returns error if validation fails
* Automatically sets appropriate error responses

---

## 6. URL Parameters

### Path Parameters

```go
type ItemUri struct {
	ID string `uri:"id" binding:"required"`
}

func getItemByID(c *gin.Context) {
	var uri ItemUri
	
	if err := c.BindUri(&uri); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	for _, item := range items {
		if item.ID == uri.ID {
			c.IndentedJSON(http.StatusOK, item)
			return
		}
	}
	
	c.IndentedJSON(http.StatusNotFound, gin.H{
		"message": "Item not found",
	})
}

r.GET("/items/:id", getItemByID)
```

**Key Points:**

* Use `:id` in route to define parameter
* Define struct with `uri` tag
* Use `c.BindUri(&uri)` to validate and bind
* Access validated parameter via struct field

---

### Alternative: Direct Parameter Access

```go
func getItemByID(c *gin.Context) {
	id := c.Param("id")
	
	for _, item := range items {
		if item.ID == id {
			c.JSON(200, item)
			return
		}
	}
	
	c.JSON(404, gin.H{"message": "Item not found"})
}
```

✅ Simpler but no automatic validation

---

## 7. Query Parameters

### Using Struct Binding

```go
type ItemQuery struct {
	Name   string `form:"name" binding:"required"`
	Status string `form:"status"`
}

func listItems(c *gin.Context) {
	var query ItemQuery
	
	if err := c.ShouldBindQuery(&query); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	// Filter items by query.Name
	var filtered []Item
	for _, item := range items {
		if item.Name == query.Name {
			filtered = append(filtered, item)
		}
	}
	
	c.IndentedJSON(http.StatusOK, filtered)
}

r.GET("/items", listItems)
```

**Example Request:**

```
GET /items?name=apple&status=active
```

---

### Alternative: Direct Query Access

```go
func listItems(c *gin.Context) {
	name := c.Query("name")          // Returns empty string if not found
	status := c.DefaultQuery("status", "all") // With default value
	
	c.JSON(200, gin.H{
		"name":   name,
		"status": status,
	})
}
```

---

## 8. Binding Methods Comparison

| Method                | Use Case               | Behavior on Error |
| --------------------- | ---------------------- | ----------------- |
| `c.BindJSON`          | Validate JSON body     | Aborts with 400   |
| `c.BindUri`           | Validate path params   | Aborts with 400   |
| `c.BindQuery`         | Validate query params  | Aborts with 400   |
| `c.ShouldBindJSON`    | Non-abortive JSON bind | Returns error     |
| `c.ShouldBindQuery`   | Non-abortive query bind| Returns error     |

**Best Practice:**

* Use `Bind*` for simple APIs
* Use `ShouldBind*` when you need custom error handling

---

## 9. Response Methods

### JSON Response

```go
c.JSON(200, gin.H{
	"message": "success",
})
```

### Indented JSON (for debugging)

```go
c.IndentedJSON(200, data)
```

### String Response

```go
c.String(200, "Hello, %s", name)
```

### HTML Response

```go
c.HTML(200, "index.html", gin.H{
	"title": "Home",
})
```

### Redirect

```go
c.Redirect(http.StatusMovedPermanently, "/new-path")
```

### Status Only

```go
c.Status(204) // No Content
```

---

## 10. Route Groups

Organize related routes with common prefixes or middleware.

```go
api := r.Group("/api/v1")
{
	api.GET("/items", listItems)
	api.POST("/items", addItem)
	api.GET("/items/:id", getItemByID)
	api.DELETE("/items/:id", deleteItem)
}

admin := r.Group("/admin")
admin.Use(authMiddleware()) // Apply middleware to group
{
	admin.GET("/users", getUsers)
	admin.DELETE("/users/:id", deleteUser)
}
```

---

## 11. Running the Server

### Default Port (8080)

```go
r.Run()
```

### Custom Port

```go
r.Run(":3000")
```

### Custom Address and Port

```go
r.Run("192.168.1.1:8080")
```

---

## 12. Complete Example

```go
package main

import (
	"net/http"
	"github.com/gin-gonic/gin"
)

type Item struct {
	ID   string `json:"id" binding:"required"`
	Name string `json:"name" binding:"required"`
}

var items = []Item{
	{ID: "1", Name: "Apple"},
	{ID: "2", Name: "Banana"},
}

func main() {
	r := gin.Default()
	
	// Routes
	r.GET("/items", getItems)
	r.GET("/items/:id", getItemByID)
	r.POST("/items", addItem)
	
	r.Run(":8080")
}

func getItems(c *gin.Context) {
	c.JSON(http.StatusOK, items)
}

func getItemByID(c *gin.Context) {
	id := c.Param("id")
	
	for _, item := range items {
		if item.ID == id {
			c.JSON(http.StatusOK, item)
			return
		}
	}
	
	c.JSON(http.StatusNotFound, gin.H{
		"message": "Item not found",
	})
}

func addItem(c *gin.Context) {
	var newItem Item
	
	if err := c.BindJSON(&newItem); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	items = append(items, newItem)
	c.JSON(http.StatusCreated, newItem)
}
```

---

## 13. Best Practices

✅ Use `gin.Default()` for most cases (includes logging and recovery)

✅ Organize routes with groups

✅ Use struct tags for validation

✅ Handle errors explicitly

✅ Use `ShouldBind*` for custom error responses

✅ Return proper HTTP status codes

✅ Keep handlers small and focused

❌ Don't ignore binding errors

❌ Don't use `gin.New()` unless you need minimal middleware

❌ Don't forget to validate user input

---

## 14. Common Status Codes

| Code | Constant               | Meaning          |
| ---- | ---------------------- | ---------------- |
| 200  | http.StatusOK          | Success          |
| 201  | http.StatusCreated     | Resource created |
| 400  | http.StatusBadRequest  | Invalid request  |
| 404  | http.StatusNotFound    | Not found        |
| 500  | http.StatusInternalServerError | Server error |

---

## Summary

Gin provides a clean, performant way to build web APIs in Go:

* **Simple routing** with Express.js-like syntax
* **Automatic validation** via struct tags
* **Built-in middleware** for logging and recovery
* **Flexible binding** for JSON, query params, and URI params
* **Route grouping** for organized APIs
* **Fast performance** due to httprouter under the hood

Use Gin when you need a lightweight, fast framework with minimal boilerplate.



