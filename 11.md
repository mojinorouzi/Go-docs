# Gin Framework

Gin is a high-performance HTTP web framework for Go that provides a simple and expressive API for building RESTful APIs and web applications.

Key features:

* Fast (up to 40x faster than some frameworks)
* Martini-like API with better performance
* Built-in middleware support
* JSON validation
* Route grouping
* Error management

---

## 1. Installation

```bash
go get -u github.com/gin-gonic/gin
```

---

## 2. Creating an HTTP Server

### Basic Server Setup

```go
package main

import "github.com/gin-gonic/gin"

func main() {
	r := gin.Default()
	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})
	
	r.Run() // Listen on 0.0.0.0:8080
}
```

### What is `gin.Default()`?

`gin.Default()` creates a Gin router with **Logger** and **Recovery** middleware already attached.

Equivalent to:

```go
r := gin.New()
r.Use(gin.Logger())
r.Use(gin.Recovery())
```

---

## 3. Middleware

### What is Recovery Middleware?

The **Recovery middleware** recovers from any panics during HTTP request handling:

* Prevents server crashes
* Returns a **500 Internal Server Error** response
* Logs the panic error and stack trace for debugging

```go
r.Use(gin.Recovery())
```

‚úÖ `gin.Default()` includes both Logger and Recovery by default.

---

### Custom Middleware Example

```go
func customLogger() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Before request
		start := time.Now()
		
		c.Next() // Process request
		
		// After request
		duration := time.Since(start)
		fmt.Printf("Request took %v\n", duration)
	}
}

r.Use(customLogger())
```

---

## 4. Understanding `*gin.Context`

### What is `gin.Context`?

`*gin.Context` is a pointer to the context object that represents the current HTTP request.

It provides methods to:

| Category     | Methods                                      |
| ------------ | -------------------------------------------- |
| Read Request | Query, Param, BindJSON, BindUri, GetHeader   |
| Send Response| JSON, IndentedJSON, String, HTML, Redirect   |
| Control Flow | Next, Abort, AbortWithStatus                 |
| Data Storage | Set, Get (store data during request lifecycle)|

### Why Use a Pointer (`*gin.Context`)?

* Avoids copying large context objects
* Allows modifications to affect the original context
* More efficient memory usage

---

## 5. Route Handlers (Controllers)

Gin uses an **Express.js-like style** where you define routes and callback functions.

### GET Request Example

```go
r.GET("/ping", func(c *gin.Context) {
	c.JSON(200, gin.H{
		"message": "pong",
	})
})
```

**Explanation:**

* `r.GET` ‚Üí Define GET route
* `"/ping"` ‚Üí Route path
* `func(c *gin.Context)` ‚Üí Handler function
* `c.JSON` ‚Üí Send JSON response
* `gin.H` ‚Üí Shortcut for `map[string]interface{}`

---

### POST Request Example

```go
type Item struct {
	ID   string `json:"id" binding:"required"`
	Name string `json:"name" binding:"required"`
}

var items []Item

func addItem(c *gin.Context) {
	var newItem Item
	
	// Bind and validate JSON body
	if err := c.BindJSON(&newItem); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	items = append(items, newItem)
	c.IndentedJSON(http.StatusCreated, newItem)
}

r.POST("/items", addItem)
```

**What does `c.BindJSON` do?**

* Parses JSON request body
* Validates against struct tags (`binding:"required"`)
* Returns error if validation fails
* Automatically sets appropriate error responses

---

## 6. URL Parameters

### Path Parameters

```go
type ItemUri struct {
	ID string `uri:"id" binding:"required"`
}

func getItemByID(c *gin.Context) {
	var uri ItemUri
	
	if err := c.BindUri(&uri); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	for _, item := range items {
		if item.ID == uri.ID {
			c.IndentedJSON(http.StatusOK, item)
			return
		}
	}
	
	c.IndentedJSON(http.StatusNotFound, gin.H{
		"message": "Item not found",
	})
}

r.GET("/items/:id", getItemByID)
```

**Key Points:**

* Use `:id` in route to define parameter
* Define struct with `uri` tag
* Use `c.BindUri(&uri)` to validate and bind
* Access validated parameter via struct field

---

### Alternative: Direct Parameter Access

```go
func getItemByID(c *gin.Context) {
	id := c.Param("id")
	
	for _, item := range items {
		if item.ID == id {
			c.JSON(200, item)
			return
		}
	}
	
	c.JSON(404, gin.H{"message": "Item not found"})
}
```

‚úÖ Simpler but no automatic validation

---

## 7. Query Parameters

### Using Struct Binding

```go
type ItemQuery struct {
	Name   string `form:"name" binding:"required"`
	Status string `form:"status"`
}

func listItems(c *gin.Context) {
	var query ItemQuery
	
	if err := c.ShouldBindQuery(&query); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	// Filter items by query.Name
	var filtered []Item
	for _, item := range items {
		if item.Name == query.Name {
			filtered = append(filtered, item)
		}
	}
	
	c.IndentedJSON(http.StatusOK, filtered)
}

r.GET("/items", listItems)
```

**Example Request:**

```
GET /items?name=apple&status=active
```

---

### Alternative: Direct Query Access

```go
func listItems(c *gin.Context) {
	name := c.Query("name")          // Returns empty string if not found
	status := c.DefaultQuery("status", "all") // With default value
	
	c.JSON(200, gin.H{
		"name":   name,
		"status": status,
	})
}
```

---

## 8. File Upload and Form Data

File uploads in Gin combine form data validation with file handling. You can accept both regular form fields and files in the same request.

### Complete File Upload Example

```go
type UploadForm struct {
	Name string `form:"name" binding:"required"`
}

func uploadFile(c *gin.Context) {
	// Validate form field
	var form UploadForm
	if err := c.ShouldBind(&form); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get file header
	file, err := c.FormFile("file")
	if err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"error": "File is required"})
		return
	}

	// Open file as stream
	src, err := file.Open()
	if err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"error": "Cannot open file"})
		return
	}
	defer src.Close()

	// Validate file type by reading first 512 bytes
	buf := make([]byte, 512)
	n, _ := src.Read(buf)
	contentType := http.DetectContentType(buf[:n])
	if contentType != "image/png" && contentType != "image/jpeg" {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"error": "Only PNG and JPEG files are allowed"})
		return
	}

	// Reset stream to start
	src.Seek(0, 0)

	// Save file streamly
	dstPath := "./uploads/" + file.Filename
	dst, err := createFile(dstPath)
	if err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"error": "Cannot save file"})
		return
	}
	defer dst.Close()

	_, err = io.Copy(dst, src)
	if err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"error": "Failed to save file"})
		return
	}

	c.IndentedJSON(http.StatusOK, gin.H{
		"name":        form.Name,
		"file":        file.Filename,
		"contentType": contentType,
	})
}

// Helper to create file and directory if needed
func createFile(path string) (*os.File, error) {
	if err := os.MkdirAll("./uploads", 0755); err != nil {
		return nil, err
	}
	return os.Create(path)
}
```

---

### Understanding Form Data Validation

**What is Form Data?**

Form data is sent with `Content-Type: multipart/form-data` and can contain:

* Regular text fields
* File uploads
* Both combined

**How Validation Works:**

```go
type UploadForm struct {
	Name string `form:"name" binding:"required"`
}

var form UploadForm
c.ShouldBind(&form)
```

**Steps:**

1. Define struct with `form` tag (not `json`)
2. Use `c.ShouldBind()` (works for both JSON and form data)
3. Gin automatically parses `multipart/form-data`
4. Validates against binding rules

**Example HTML form:**

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
  <input type="text" name="name" required>
  <input type="file" name="file" required>
  <button type="submit">Upload</button>
</form>
```

---

### File Type Validation

**Why Validate File Types?**

* Security: Prevent malicious file uploads
* Compatibility: Ensure correct file format
* Business rules: Only accept specific types (images, PDFs, etc.)

**How `http.DetectContentType` Works:**

```go
buf := make([]byte, 512)
n, _ := src.Read(buf)
contentType := http.DetectContentType(buf[:n])
```

**Explanation:**

1. **Read first 512 bytes** ‚Üí File signatures (magic numbers) are in the header
2. **Detect type** ‚Üí Uses built-in Go algorithm to identify MIME type
3. **Validate** ‚Üí Check against allowed types

**Important:**

* Does **NOT** rely on file extension (`.jpg`, `.png`)
* Reads actual file content (more secure)
* Checks file signature/magic bytes

**Common Content Types:**

| Type       | MIME Type       | Magic Bytes    |
| ---------- | --------------- | -------------- |
| PNG        | `image/png`     | `89 50 4E 47`  |
| JPEG       | `image/jpeg`    | `FF D8 FF`     |
| PDF        | `application/pdf` | `25 50 44 46` |
| ZIP        | `application/zip` | `50 4B 03 04` |

‚ùå **Bad approach** (can be spoofed):

```go
// Only checking extension
if !strings.HasSuffix(filename, ".png") {
	// Insecure!
}
```

‚úÖ **Good approach** (checking actual content):

```go
contentType := http.DetectContentType(buf[:n])
if contentType != "image/png" {
	// Secure!
}
```

---

### Understanding `src.Seek(0, 0)`

**What is `Seek`?**

`Seek` moves the file read position (like a cursor).

**Syntax:**

```go
src.Seek(offset, whence)
```

* **offset** ‚Üí How many bytes to move
* **whence** ‚Üí Where to start:
  * `0` ‚Üí Start of file (`io.SeekStart`)
  * `1` ‚Üí Current position (`io.SeekCurrent`)
  * `2` ‚Üí End of file (`io.SeekEnd`)

**Why `src.Seek(0, 0)` is Needed:**

After reading the first 512 bytes for validation:

```go
buf := make([]byte, 512)
n, _ := src.Read(buf) // ‚Üê cursor is now at byte 512
```

The file cursor is at position 512.

If you save the file now:

```go
io.Copy(dst, src) // ‚ùå Only copies from byte 512 to end
```

You'll **lose the first 512 bytes**!

**Solution:**

```go
src.Seek(0, 0) // Reset cursor to start
io.Copy(dst, src) // ‚úÖ Copies entire file
```

**Mental Model:**

Think of reading a book:

1. Read first page (validation)
2. Bookmark is now on page 2
3. `Seek(0, 0)` ‚Üí Go back to page 1
4. Now read entire book from start

---

### Saving Files Streamly with `io.Copy`

**What is Streaming?**

Instead of loading the entire file into memory:

‚ùå **Bad (non-streaming):**

```go
data, _ := io.ReadAll(src) // Loads entire file into RAM
os.WriteFile(path, data, 0644)
```

Problems:

* Uses lots of memory
* Crashes with large files (500MB+)
* Slow

‚úÖ **Good (streaming):**

```go
dst, _ := os.Create(path)
io.Copy(dst, src) // Copies in chunks
```

Benefits:

* Memory efficient (uses ~32KB buffer)
* Works with files of any size
* Fast

**How `io.Copy` Works:**

```go
io.Copy(dst, src)
```

**Internal process:**

1. Reads a chunk from source (default 32KB)
2. Writes chunk to destination
3. Repeats until EOF
4. Returns total bytes copied

**Comparison:**

| Approach     | 100MB File RAM Usage | Can Handle 5GB? |
| ------------ | -------------------- | --------------- |
| `ReadAll`    | ~100MB               | ‚ùå Crashes      |
| `io.Copy`    | ~32KB                | ‚úÖ Works        |

**Real-World Example:**

Uploading a 2GB video:

```go
// This works perfectly
io.Copy(dst, src) // Uses only 32KB RAM
```

---

### Complete Flow Explanation

```go
func uploadFile(c *gin.Context) {
	// Step 1: Validate text fields
	var form UploadForm
	c.ShouldBind(&form)
	
	// Step 2: Get file reference
	file, _ := c.FormFile("file")
	
	// Step 3: Open file stream (like opening a tap üö∞)
	src, _ := file.Open()
	defer src.Close()
	
	// Step 4: Peek at first 512 bytes (validation)
	buf := make([]byte, 512)
	src.Read(buf)
	contentType := http.DetectContentType(buf[:512])
	
	// Step 5: Reset to beginning (important!)
	src.Seek(0, 0)
	
	// Step 6: Stream entire file to disk
	dst, _ := os.Create(path)
	defer dst.Close()
	io.Copy(dst, src) // Efficient streaming
}
```

**Why This Approach is Best:**

‚úÖ **Validates** form data

‚úÖ **Secures** with content-type checking

‚úÖ **Efficient** with streaming

‚úÖ **Scalable** for large files

‚úÖ **Safe** with proper error handling

---

### Register the Route

```go
r.POST("/upload", uploadFile)
```

---

### Testing with cURL

```bash
curl -X POST http://localhost:8080/upload \
  -F "name=MyImage" \
  -F "file=@/path/to/image.png"
```

---

### Key Takeaways

| Concept          | Purpose                          | Why Important         |
| ---------------- | -------------------------------- | --------------------- |
| `form` tag       | Parse multipart form data        | Mix text + files      |
| `c.FormFile`     | Get file from request            | Access uploaded file  |
| `DetectContentType` | Validate actual file type     | Security              |
| `Seek(0, 0)`     | Reset file cursor to start       | Save complete file    |
| `io.Copy`        | Stream file in chunks            | Memory efficiency     |
| `defer Close()`  | Clean up resources               | Prevent leaks         |

---

## 9. Binding Methods Comparison

| Method                | Use Case               | Behavior on Error |
| --------------------- | ---------------------- | ----------------- |
| `c.BindJSON`          | Validate JSON body     | Aborts with 400   |
| `c.BindUri`           | Validate path params   | Aborts with 400   |
| `c.BindQuery`         | Validate query params  | Aborts with 400   |
| `c.ShouldBindJSON`    | Non-abortive JSON bind | Returns error     |
| `c.ShouldBindQuery`   | Non-abortive query bind| Returns error     |

**Best Practice:**

* Use `Bind*` for simple APIs
* Use `ShouldBind*` when you need custom error handling

---

## 10. Response Methods

### JSON Response

```go
c.JSON(200, gin.H{
	"message": "success",
})
```

### Indented JSON (for debugging)

```go
c.IndentedJSON(200, data)
```

### String Response

```go
c.String(200, "Hello, %s", name)
```

### HTML Response

```go
c.HTML(200, "index.html", gin.H{
	"title": "Home",
})
```

### Redirect

```go
c.Redirect(http.StatusMovedPermanently, "/new-path")
```

### Status Only

```go
c.Status(204) // No Content
```

---

## 11. Route Groups

Organize related routes with common prefixes or middleware.

```go
api := r.Group("/api/v1")
{
	api.GET("/items", listItems)
	api.POST("/items", addItem)
	api.GET("/items/:id", getItemByID)
	api.DELETE("/items/:id", deleteItem)
}

admin := r.Group("/admin")
admin.Use(authMiddleware()) // Apply middleware to group
{
	admin.GET("/users", getUsers)
	admin.DELETE("/users/:id", deleteUser)
}
```

---

## 12. Running the Server

### Default Port (8080)

```go
r.Run()
```

### Custom Port

```go
r.Run(":3000")
```

### Custom Address and Port

```go
r.Run("192.168.1.1:8080")
```

---

## 13. Complete Example

```go
package main

import (
	"net/http"
	"github.com/gin-gonic/gin"
)

type Item struct {
	ID   string `json:"id" binding:"required"`
	Name string `json:"name" binding:"required"`
}

var items = []Item{
	{ID: "1", Name: "Apple"},
	{ID: "2", Name: "Banana"},
}

func main() {
	r := gin.Default()
	
	// Routes
	r.GET("/items", getItems)
	r.GET("/items/:id", getItemByID)
	r.POST("/items", addItem)
	
	r.Run(":8080")
}

func getItems(c *gin.Context) {
	c.JSON(http.StatusOK, items)
}

func getItemByID(c *gin.Context) {
	id := c.Param("id")
	
	for _, item := range items {
		if item.ID == id {
			c.JSON(http.StatusOK, item)
			return
		}
	}
	
	c.JSON(http.StatusNotFound, gin.H{
		"message": "Item not found",
	})
}

func addItem(c *gin.Context) {
	var newItem Item
	
	if err := c.BindJSON(&newItem); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	
	items = append(items, newItem)
	c.JSON(http.StatusCreated, newItem)
}
```

---

## 14. Best Practices

‚úÖ Use `gin.Default()` for most cases (includes logging and recovery)

‚úÖ Organize routes with groups

‚úÖ Use struct tags for validation

‚úÖ Handle errors explicitly

‚úÖ Use `ShouldBind*` for custom error responses

‚úÖ Return proper HTTP status codes

‚úÖ Keep handlers small and focused

‚ùå Don't ignore binding errors

‚ùå Don't use `gin.New()` unless you need minimal middleware

‚ùå Don't forget to validate user input

---

## 15. Common Status Codes

| Code | Constant               | Meaning          |
| ---- | ---------------------- | ---------------- |
| 200  | http.StatusOK          | Success          |
| 201  | http.StatusCreated     | Resource created |
| 400  | http.StatusBadRequest  | Invalid request  |
| 404  | http.StatusNotFound    | Not found        |
| 500  | http.StatusInternalServerError | Server error |

---

## Summary

Gin provides a clean, performant way to build web APIs in Go:

* **Simple routing** with Express.js-like syntax
* **Automatic validation** via struct tags
* **Built-in middleware** for logging and recovery
* **Flexible binding** for JSON, query params, and URI params
* **Route grouping** for organized APIs
* **Fast performance** due to httprouter under the hood

Use Gin when you need a lightweight, fast framework with minimal boilerplate.



