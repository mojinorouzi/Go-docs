# Structs in Go

A **struct** is a composite data type that groups related values (fields) together under a single name.

In Go:

* A struct **definition** only declares field names and their types.
* You **cannot assign values** inside the type definition.
* Values are assigned later when creating variables.

---

## Defining a Struct Type

```go
type Person struct {
	name string
	age  int
}
```

---

## Creating Struct Values

### Using a Composite Literal (Recommended)

```go
person := Person{
	name: "jack",
	age:  12,
}
```

### Declaring First, Assigning Later

```go
var person Person

person.name = "jack"
person.age = 12
```

---

## Zero Values

When you declare a struct without initializing its fields, Go assigns **zero values**:

| Type   | Zero Value |
| ------ | ---------- |
| string | `""`       |
| int    | `0`        |
| float  | `0`        |
| bool   | `false`    |

---

## Printing Structs Nicely

```go
fmt.Printf("%+v", person)
```

* `%v` prints values
* `%+v` prints field names **and** values (much more readable)

---

# Type Embedding (Struct Composition)

Type embedding allows one struct to include another struct as a field.

### Example

```go
type ContactInfo struct {
	number  int
	address string
}

type Person struct {
	name        string
	age         int
	contactInfo ContactInfo
}
```

### Creating a Nested Struct

```go
person := Person{
	name: "jack",
	age:  12,
	contactInfo: ContactInfo{
		number:  12,
		address: "Iran",
	},
}
```

---

# Pointers in Go

Consider this method:

```go
func (person Person) updateName(name string) {
	person.name = name
}
```

### ‚ùå Why doesn‚Äôt this update the original struct?

Because **Go is pass-by-value**.

* The method receives a **copy** of `Person`
* Changes affect only the copy, not the original

---

## Fix: Use Pointer Receivers

```go
func (person *Person) updateName(name string) {
	person.name = name
}
```

### Why this works

* `*Person` means the method receives the **address** of the struct
* Changes are applied to the original value in memory

---

## Understanding `*` and `&`

```go
x := 10
p := &x
```

| Expression | Meaning                      |
| ---------- | ---------------------------- |
| `&x`       | address of `x`               |
| `*p`       | value stored at that address |
| `*int`     | pointer to an `int`          |
| `nil`      | no address                   |

---

# Important Note About Slices

A slice internally contains **two levels of memory**:

1. **Slice header** (copied when passed to functions)

   * pointer to data
   * length
   * capacity
2. **Underlying array** (shared)

Because of this:

* Passing a slice copies the header
* Both slices still point to the **same underlying array**

---

## Slice Example

```go
func updateFirstElement(arr []string) {
	arr[0] = "jack"
}
```

Even though `arr` is passed by value:

* The underlying array is shared
* Modifying elements affects the original slice

---

## Key Conclusions

### Structs

* Structs are **value types**
* Passing them copies the entire value
* Use pointers to modify them

### Slices

* Slices behave like **reference types**
* The slice header is copied
* The underlying data is shared

---

# Value Types in Go

* int
* float
* string
* bool
* struct

---

# Reference-like Types in Go

* slice
* map
* channel
* pointer
* function

---

‚úÖ Tip: When in doubt, ask yourself ‚Äî *am I modifying the value itself, or the data it points to?*



## How copy slices ?

this is **super important in Go** üëç
Short answer: **you must copy the underlying array**, not just assign the slice.

---

## ‚ùå Wrong way (this does NOT copy)

```go
a := []int{1, 2, 3}
b := a
```

What happens:

* `a` and `b` point to the **same underlying array**
* Changing one changes the other

```go
b[0] = 100
fmt.Println(a) // [100 2 3]
```

---

## ‚úÖ Correct way: `copy` (most common)

```go
a := []int{1, 2, 3}
b := make([]int, len(a))

copy(b, a)
```

Now:

* `b` has its **own underlying array**
* Safe to modify independently

```go
b[0] = 100
fmt.Println(a) // [1 2 3]
fmt.Println(b) // [100 2 3]
```

---

## ‚úÖ One-liner copy (idiomatic)

```go
b := append([]int(nil), a...)
```

Why this works:

* `[]int(nil)` creates a new slice
* `append` allocates new memory
* `a...` copies elements

üî• Very common in real Go code.

---

## ‚úÖ Copy part of a slice

```go
a := []int{1, 2, 3, 4, 5}
b := make([]int, 3)

copy(b, a[1:4]) // copies 2,3,4
```

---

## ‚úÖ Deep copy vs shallow copy (important idea)

### Shallow copy (default behavior)

```go
b := a
```

* Copies slice header only
* Shares data

### Deep copy (what you want)

```go
b := make([]T, len(a))
copy(b, a)
```

* New header
* New data

---

## üß† Mental model

> **Slices are small structs pointing to big arrays**

To truly copy a slice:

> **You must copy the array it points to**

---

## ‚ö†Ô∏è Special case: slice of structs or pointers

```go
type User struct {
    Name string
}

a := []User{{"Alice"}, {"Bob"}}
b := make([]User, len(a))
copy(b, a)
```

This is fine **if fields are value types**.

But if you have pointers inside:

```go
[]*User
```

You‚Äôll need a **manual deep copy**.

### manual deep copy

``` go

dst := make([]*T, len(src))

for i, v := range src {
	if v == nil {
		continue
	}

	c := *v          // copy value
	// deep copy inner fields here
	dst[i] = &c
}

```